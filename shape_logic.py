import pygame, math

def get_circle_hitboxes(center, radius):
    # this function turns circle attributes into a collection of rectangles that emulate the circle
    # every pixel, the height is determined by finding the height of the leg, where the radius would be the hypotenuse
    # and the other leg is the horizontal distance away from the radius
    # then it makes a rect based on this determined value
    
    circle_hitboxes = []
    diameter = 2 * radius
    center_x = center[0]
    center_y = center[1]
    
    circle_hitboxes.append(pygame.Rect(center_x, center_y - radius, 1, diameter))
    
    for i in range(radius):
        if i != 0:
            rect_height = 0
            """
            derivation:
            circle formula = r^2 = x^2 + y^2 (** is the operand for exponentiation)
            where x is the horizontal distance from the center, and y is the vertical distance (pythagorean theorem)
            i is the integration amount, therefore that is our horizontal distance
            and we need to find the vertical distance
            quickly substitute
            move the rect_height to the left side and the radius to the right
            r          x     y
            radius^2 = i^2 + rect_height^2
            
            - rect_height^2 = i^2 - radius^2
            absolute value (i^2 - r^2) as negative numbers cannot be rooted
            then square root
            """
            
            rect_height = math.ceil(math.sqrt(abs(i**2 - radius**2)))
            
            circle_hitboxes.append(pygame.Rect(center_x - i, center_y - rect_height, 1, rect_height*2))
            circle_hitboxes.append(pygame.Rect(center_x + i, center_y - rect_height, 1, rect_height*2))
            
    return circle_hitboxes

def get_line_hitboxes(start_pos, end_pos, thickness): # start_pos_x MUST BE LESS THAN end_pos_x
    # this function gets the rect hitboxes for a line argument
    # the top value gets the distance from the center of any point on the line to the top
    # as pygame line thickness is generated by going half the thickness away in any direction
    
    line_hitboxes = []
    
    top_value = math.floor(thickness / 2)
    
    # find the slope of the line
    start_pos_x = start_pos[0]
    start_pos_y = start_pos[1]
    end_pos_x = end_pos[0]
    end_pos_y = end_pos[1]
    
    delta_x = end_pos_x - start_pos_x
    delta_y = end_pos_y - start_pos_y
    
    slope = delta_y / delta_x
    ### ------
    
    # so now we go along the line and create rects for each point in the slope
    for i in range(delta_x):
        new_pos_y = start_pos_y + (slope*i)
        if slope <= 1:
            line_hitboxes.append(pygame.Rect(start_pos_x + i, new_pos_y - (top_value - 1), math.ceil(slope), thickness))
        else:
            # there was some weird down-left offset created and 9 is the estimated pixels that i found it to be
            line_hitboxes.append(pygame.Rect((start_pos_x + i) - 9, (new_pos_y - (top_value - 1)) + 9, thickness, math.ceil(slope)))
    
    return line_hitboxes